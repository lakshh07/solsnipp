{
  "ERC1155 NFT Smart Contract": {
    "__typename": "Snippet",
    "label": "ERC1155 NFT Smart Contract",
    "description": "Basic Template for ERC1155 NFT Smart Contract with Openzeppelin",
    "body": [
      "// SPDX-License-Identifier: MIT",
      "// Amended by SolSnipp",
      "/**",
      "    !Disclaimer!",
      "    ",
      "    These contracts have been used to create tutorials,",
      "    please review this code on your own before using any of",
      "    the following code for production.",
      "*/",
      "pragma solidity >=0.7.0 <0.9.0;",
      "import \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";",
      "import \"@openzeppelin/contracts/access/Ownable.sol\";",
      "contract NFT1155 is ERC1155, Ownable {",
      "    ",
      "  string public name;",
      "  string public symbol;",
      "  mapping(uint => string) public tokenURI;",
      "  constructor() ERC1155(\"\") {",
      "    name = \"Snippets\";",
      "    symbol = \"SolSnipp\";",
      "  }",
      "  function mint(address _to, uint _id, uint _amount) external onlyOwner {",
      "    _mint(_to, _id, _amount, \"\");",
      "  }",
      "  function mintBatch(address _to, uint[] memory _ids, uint[] memory _amounts) external onlyOwner {",
      "    _mintBatch(_to, _ids, _amounts, \"\");",
      "  }",
      "  function burn(uint _id, uint _amount) external {",
      "    _burn(msg.sender, _id, _amount);",
      "  }",
      "  function burnBatch(uint[] memory _ids, uint[] memory _amounts) external {",
      "    _burnBatch(msg.sender, _ids, _amounts);",
      "  }",
      "  function burnForMint(address _from, uint[] memory _burnIds, uint[] memory _burnAmounts, uint[] memory _mintIds, uint[] memory _mintAmounts) external onlyOwner {",
      "    _burnBatch(_from, _burnIds, _burnAmounts);",
      "    _mintBatch(_from, _mintIds, _mintAmounts, \"\");",
      "  }",
      "  function setURI(uint _id, string memory _uri) external onlyOwner {",
      "    tokenURI[_id] = _uri;",
      "    emit URI(_uri, _id);",
      "  }",
      "  function uri(uint _id) public override view returns (string memory) {",
      "    return tokenURI[_id];",
      "  }",
      "}",
      "    ",
      ""
    ],
    "prefix": "erc1155"
  },
  "ERC20 Token Smart Contract": {
    "__typename": "Snippet",
    "label": "ERC20 Token Smart Contract",
    "description": "Basic ERC20 Token Smart Contract template with OpenZeppelin",
    "body": [
      "// SPDX-License-Identifier: MIT",
      "pragma solidity >=0.7.0 <0.9.0;",
      "import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";",
      "contract SolSnippToken is ERC20 {",
      "    constructor(string memory name, string memory symbol) ERC20(name, symbol) {",
      "        // Mint 100 tokens to msg.sender",
      "        // Similar to how",
      "        // 1 dollar = 100 cents",
      "        // 1 token = 1 * (10 ** decimals)",
      "        _mint(msg.sender, 100 * 10**uint(decimals()));",
      "    }",
      "}",
      ""
    ],
    "prefix": "erc20"
  },
  "ERC721 NFT Smart Contract": {
    "__typename": "Snippet",
    "label": "ERC721 NFT Smart Contract",
    "description": "Basic ERC721 NFT Smart Contract template using Openzeppelin",
    "body": [
      "// SPDX-License-Identifier: MIT",
      "// Amended by SolSnipp",
      "/**",
      "    !Disclaimer!",
      "    These contracts have been used to create tutorials,",
      "    and was created for the purpose to teach people",
      "*/",
      "pragma solidity >=0.7.0 <0.9.0;",
      "import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";",
      "import \"@openzeppelin/contracts/access/Ownable.sol\";",
      "contract NFT is ERC721Enumerable, Ownable {",
      "  using Strings for uint256;",
      "  string baseURI;",
      "  string public baseExtension = \".json\";",
      "  uint256 public cost = 0.05 ether;",
      "  uint256 public maxSupply = 10000;",
      "  uint256 public maxMintAmount = 20;",
      "  bool public paused = false;",
      "  bool public revealed = false;",
      "  string public notRevealedUri;",
      "  constructor(",
      "    string memory _name,",
      "    string memory _symbol,",
      "    string memory _initBaseURI,",
      "    string memory _initNotRevealedUri",
      "  ) ERC721(_name, _symbol) {",
      "    setBaseURI(_initBaseURI);",
      "    setNotRevealedURI(_initNotRevealedUri);",
      "  }",
      "  // internal",
      "  function _baseURI() internal view virtual override returns (string memory) {",
      "    return baseURI;",
      "  }",
      "  // public",
      "  function mint(uint256 _mintAmount) public payable {",
      "    uint256 supply = totalSupply();",
      "    require(!paused);",
      "    require(_mintAmount > 0);",
      "    require(_mintAmount <= maxMintAmount);",
      "    require(supply + _mintAmount <= maxSupply);",
      "    if (msg.sender != owner()) {",
      "      require(msg.value >= cost * _mintAmount);",
      "    }",
      "    for (uint256 i = 1; i <= _mintAmount; i++) {",
      "      _safeMint(msg.sender, supply + i);",
      "    }",
      "  }",
      "  function walletOfOwner(address _owner)",
      "    public",
      "    view",
      "    returns (uint256[] memory)",
      "  {",
      "    uint256 ownerTokenCount = balanceOf(_owner);",
      "    uint256[] memory tokenIds = new uint256[](ownerTokenCount);",
      "    for (uint256 i; i < ownerTokenCount; i++) {",
      "      tokenIds[i] = tokenOfOwnerByIndex(_owner, i);",
      "    }",
      "    return tokenIds;",
      "  }",
      "  function tokenURI(uint256 tokenId)",
      "    public",
      "    view",
      "    virtual",
      "    override",
      "    returns (string memory)",
      "  {",
      "    require(",
      "      _exists(tokenId),",
      "      \"ERC721Metadata: URI query for nonexistent token\"",
      "    );",
      "    ",
      "    if(revealed == false) {",
      "        return notRevealedUri;",
      "    }",
      "    string memory currentBaseURI = _baseURI();",
      "    return bytes(currentBaseURI).length > 0",
      "        ? string(abi.encodePacked(currentBaseURI, tokenId.toString(), baseExtension))",
      "        : \"\";",
      "  }",
      "  //only owner",
      "  function reveal() public onlyOwner {",
      "      revealed = true;",
      "  }",
      "  ",
      "  function setCost(uint256 _newCost) public onlyOwner {",
      "    cost = _newCost;",
      "  }",
      "  function setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner {",
      "    maxMintAmount = _newmaxMintAmount;",
      "  }",
      "  ",
      "  function setNotRevealedURI(string memory _notRevealedURI) public onlyOwner {",
      "    notRevealedUri = _notRevealedURI;",
      "  }",
      "  function setBaseURI(string memory _newBaseURI) public onlyOwner {",
      "    baseURI = _newBaseURI;",
      "  }",
      "  function setBaseExtension(string memory _newBaseExtension) public onlyOwner {",
      "    baseExtension = _newBaseExtension;",
      "  }",
      "  function pause(bool _state) public onlyOwner {",
      "    paused = _state;",
      "  }",
      " ",
      "  function withdraw() public payable onlyOwner {",
      "    // This will pay SolSnipp 5% of the initial sale.",
      "    // You can remove this if you want, or keep it in to support solsnipp.",
      "    // =============================================================================",
      "    (bool hs, ) = payable(0x783017d22A71DB245bDcd0299E6ef2c9247D4016).call{value: address(this).balance * 5 / 100}(\"\");",
      "    require(hs);",
      "    // =============================================================================",
      "    ",
      "    // This will payout the owner 95% of the contract balance.",
      "    // Do not remove this otherwise you will not be able to withdraw the funds.",
      "    // =============================================================================",
      "    (bool os, ) = payable(owner()).call{value: address(this).balance}(\"\");",
      "    require(os);",
      "    // =============================================================================",
      "  }",
      "}",
      ""
    ],
    "prefix": "erc721"
  },
  "Basic Template": {
    "__typename": "Snippet",
    "label": "Basic Template",
    "description": "Simple smart contract template",
    "body": [
      "// SPDX-License-Identifier: MIT",
      "// compiler version must be greater than or equal to 0.8.13 and less than 0.9.0",
      "pragma solidity ^0.8.17;",
      "contract HelloWorld {",
      "    string public greet = \"Hello World!\";",
      "}",
      ""
    ],
    "prefix": "solstarter"
  },
  "Basic Library": {
    "__typename": "Snippet",
    "label": "Basic Library",
    "description": "Basic solidity library",
    "body": [
      "library Math {",
      "    function sqrt(uint y) internal pure returns (uint z) {",
      "        if (y > 3) {",
      "            z = y;",
      "            uint x = y / 2 + 1;",
      "            while (x < z) {",
      "                z = x;",
      "                x = (y / x + x) / 2;",
      "            }",
      "        } else if (y != 0) {",
      "            z = 1;",
      "        }",
      "        // else z = 0 (default value)",
      "    }",
      "}"
    ],
    "prefix": "sollibrary"
  },
  "Upgradeable Proxy Example": {
    "__typename": "Snippet",
    "label": "Upgradeable Proxy Example",
    "description": "This example shows how to use delegate-call and return data when fallback is called",
    "body": [
      "// SPDX-License-Identifier: MIT",
      "pragma solidity ^0.8.13;",
      "// Disclaimer by SolSnipp: Do not directly used for production!",
      "contract Proxy {",
      "    address public implementation;",
      "    function setImplementation(address _imp) external {",
      "        implementation = _imp;",
      "    }",
      "    function _delegate(address _imp) internal virtual {",
      "        assembly {",
      "            // calldatacopy(t, f, s)",
      "            // copy s bytes from calldata at position f to mem at position t",
      "            calldatacopy(0, 0, calldatasize())",
      "            // delegatecall(g, a, in, insize, out, outsize)",
      "            // - call contract at address a",
      "            // - with input mem[in…(in+insize))",
      "            // - providing g gas",
      "            // - and output area mem[out…(out+outsize))",
      "            // - returning 0 on error and 1 on success",
      "            let result := delegatecall(gas(), _imp, 0, calldatasize(), 0, 0)",
      "            // returndatacopy(t, f, s)",
      "            // copy s bytes from returndata at position f to mem at position t",
      "            returndatacopy(0, 0, returndatasize())",
      "            switch result",
      "            case 0 {",
      "                // revert(p, s)",
      "                // end execution, revert state changes, return data mem[p…(p+s))",
      "                revert(0, returndatasize())",
      "            }",
      "            default {",
      "                // return(p, s)",
      "                // end execution, return data mem[p…(p+s))",
      "                return(0, returndatasize())",
      "            }",
      "        }",
      "    }",
      "    fallback() external payable {",
      "        _delegate(implementation);",
      "    }",
      "}",
      "contract V1 {",
      "    address public implementation;",
      "    uint public x;",
      "    function inc() external {",
      "        x += 1;",
      "    }",
      "}",
      "contract V2 {",
      "    address public implementation;",
      "    uint public x;",
      "    function inc() external {",
      "        x += 1;",
      "    }",
      "    function dec() external {",
      "        x -= 1;",
      "    }",
      "}",
      ""
    ],
    "prefix": "solupgradproxy"
  },
  "Crowd Fund Example": {
    "__typename": "Snippet",
    "label": "Crowd Fund Example",
    "description": "This example shows how to create a crowdfunding smart contract",
    "body": [
      "// SPDX-License-Identifier: MIT",
      "pragma solidity ^0.8.13;",
      "interface IERC20 {",
      "    function transfer(address, uint) external returns (bool);",
      "    function transferFrom(",
      "        address,",
      "        address,",
      "        uint",
      "    ) external returns (bool);",
      "}",
      "contract CrowdFund {",
      "    event Launch(",
      "        uint id,",
      "        address indexed creator,",
      "        uint goal,",
      "        uint32 startAt,",
      "        uint32 endAt",
      "    );",
      "    event Cancel(uint id);",
      "    event Pledge(uint indexed id, address indexed caller, uint amount);",
      "    event Unpledge(uint indexed id, address indexed caller, uint amount);",
      "    event Claim(uint id);",
      "    event Refund(uint id, address indexed caller, uint amount);",
      "    struct Campaign {",
      "        // Creator of campaign",
      "        address creator;",
      "        // Amount of tokens to raise",
      "        uint goal;",
      "        // Total amount pledged",
      "        uint pledged;",
      "        // Timestamp of start of campaign",
      "        uint32 startAt;",
      "        // Timestamp of end of campaign",
      "        uint32 endAt;",
      "        // True if goal was reached and creator has claimed the tokens.",
      "        bool claimed;",
      "    }",
      "    IERC20 public immutable token;",
      "    // Total count of campaigns created.",
      "    // It is also used to generate id for new campaigns.",
      "    uint public count;",
      "    // Mapping from id to Campaign",
      "    mapping(uint => Campaign) public campaigns;",
      "    // Mapping from campaign id => pledger => amount pledged",
      "    mapping(uint => mapping(address => uint)) public pledgedAmount;",
      "    constructor(address _token) {",
      "        token = IERC20(_token);",
      "    }",
      "    function launch(",
      "        uint _goal,",
      "        uint32 _startAt,",
      "        uint32 _endAt",
      "    ) external {",
      "        require(_startAt >= block.timestamp, \"start at < now\");",
      "        require(_endAt >= _startAt, \"end at < start at\");",
      "        require(_endAt <= block.timestamp + 90 days, \"end at > max duration\");",
      "        count += 1;",
      "        campaigns[count] = Campaign({",
      "            creator: msg.sender,",
      "            goal: _goal,",
      "            pledged: 0,",
      "            startAt: _startAt,",
      "            endAt: _endAt,",
      "            claimed: false",
      "        });",
      "        emit Launch(count, msg.sender, _goal, _startAt, _endAt);",
      "    }",
      "    function cancel(uint _id) external {",
      "        Campaign memory campaign = campaigns[_id];",
      "        require(campaign.creator == msg.sender, \"not creator\");",
      "        require(block.timestamp < campaign.startAt, \"started\");",
      "        delete campaigns[_id];",
      "        emit Cancel(_id);",
      "    }",
      "    function pledge(uint _id, uint _amount) external {",
      "        Campaign storage campaign = campaigns[_id];",
      "        require(block.timestamp >= campaign.startAt, \"not started\");",
      "        require(block.timestamp <= campaign.endAt, \"ended\");",
      "        campaign.pledged += _amount;",
      "        pledgedAmount[_id][msg.sender] += _amount;",
      "        token.transferFrom(msg.sender, address(this), _amount);",
      "        emit Pledge(_id, msg.sender, _amount);",
      "    }",
      "    function unpledge(uint _id, uint _amount) external {",
      "        Campaign storage campaign = campaigns[_id];",
      "        require(block.timestamp <= campaign.endAt, \"ended\");",
      "        campaign.pledged -= _amount;",
      "        pledgedAmount[_id][msg.sender] -= _amount;",
      "        token.transfer(msg.sender, _amount);",
      "        emit Unpledge(_id, msg.sender, _amount);",
      "    }",
      "    function claim(uint _id) external {",
      "        Campaign storage campaign = campaigns[_id];",
      "        require(campaign.creator == msg.sender, \"not creator\");",
      "        require(block.timestamp > campaign.endAt, \"not ended\");",
      "        require(campaign.pledged >= campaign.goal, \"pledged < goal\");",
      "        require(!campaign.claimed, \"claimed\");",
      "        campaign.claimed = true;",
      "        token.transfer(campaign.creator, campaign.pledged);",
      "        emit Claim(_id);",
      "    }",
      "    function refund(uint _id) external {",
      "        Campaign memory campaign = campaigns[_id];",
      "        require(block.timestamp > campaign.endAt, \"not ended\");",
      "        require(campaign.pledged < campaign.goal, \"pledged >= goal\");",
      "        uint bal = pledgedAmount[_id][msg.sender];",
      "        pledgedAmount[_id][msg.sender] = 0;",
      "        token.transfer(msg.sender, bal);",
      "        emit Refund(_id, msg.sender, bal);",
      "    }",
      "}",
      ""
    ],
    "prefix": "solcrowdfund"
  },
  "Time Lock Example": {
    "__typename": "Snippet",
    "label": "Time Lock Example",
    "description": "Example time lock smart contract",
    "body": [
      "// SPDX-License-Identifier: MIT",
      "pragma solidity ^0.8.13;",
      "contract TimeLock {",
      "    error NotOwnerError();",
      "    error AlreadyQueuedError(bytes32 txId);",
      "    error TimestampNotInRangeError(uint blockTimestamp, uint timestamp);",
      "    error NotQueuedError(bytes32 txId);",
      "    error TimestampNotPassedError(uint blockTimestmap, uint timestamp);",
      "    error TimestampExpiredError(uint blockTimestamp, uint expiresAt);",
      "    error TxFailedError();",
      "    event Queue(",
      "        bytes32 indexed txId,",
      "        address indexed target,",
      "        uint value,",
      "        string func,",
      "        bytes data,",
      "        uint timestamp",
      "    );",
      "    event Execute(",
      "        bytes32 indexed txId,",
      "        address indexed target,",
      "        uint value,",
      "        string func,",
      "        bytes data,",
      "        uint timestamp",
      "    );",
      "    event Cancel(bytes32 indexed txId);",
      "    uint public constant MIN_DELAY = 10; // seconds",
      "    uint public constant MAX_DELAY = 1000; // seconds",
      "    uint public constant GRACE_PERIOD = 1000; // seconds",
      "    address public owner;",
      "    // tx id => queued",
      "    mapping(bytes32 => bool) public queued;",
      "    constructor() {",
      "        owner = msg.sender;",
      "    }",
      "    modifier onlyOwner() {",
      "        if (msg.sender != owner) {",
      "            revert NotOwnerError();",
      "        }",
      "        _;",
      "    }",
      "    receive() external payable {}",
      "    function getTxId(",
      "        address _target,",
      "        uint _value,",
      "        string calldata _func,",
      "        bytes calldata _data,",
      "        uint _timestamp",
      "    ) public pure returns (bytes32) {",
      "        return keccak256(abi.encode(_target, _value, _func, _data, _timestamp));",
      "    }",
      "    /**",
      "     * @param _target Address of contract or account to call",
      "     * @param _value Amount of ETH to send",
      "     * @param _func Function signature, for example \"foo(address,uint256)\"",
      "     * @param _data ABI encoded data send.",
      "     * @param _timestamp Timestamp after which the transaction can be executed.",
      "     */",
      "    function queue(",
      "        address _target,",
      "        uint _value,",
      "        string calldata _func,",
      "        bytes calldata _data,",
      "        uint _timestamp",
      "    ) external onlyOwner returns (bytes32 txId) {",
      "        txId = getTxId(_target, _value, _func, _data, _timestamp);",
      "        if (queued[txId]) {",
      "            revert AlreadyQueuedError(txId);",
      "        }",
      "        // ---|------------|---------------|-------",
      "        //  block    block + min     block + max",
      "        if (",
      "            _timestamp < block.timestamp + MIN_DELAY ||",
      "            _timestamp > block.timestamp + MAX_DELAY",
      "        ) {",
      "            revert TimestampNotInRangeError(block.timestamp, _timestamp);",
      "        }",
      "        queued[txId] = true;",
      "        emit Queue(txId, _target, _value, _func, _data, _timestamp);",
      "    }",
      "    function execute(",
      "        address _target,",
      "        uint _value,",
      "        string calldata _func,",
      "        bytes calldata _data,",
      "        uint _timestamp",
      "    ) external payable onlyOwner returns (bytes memory) {",
      "        bytes32 txId = getTxId(_target, _value, _func, _data, _timestamp);",
      "        if (!queued[txId]) {",
      "            revert NotQueuedError(txId);",
      "        }",
      "        // ----|-------------------|-------",
      "        //  timestamp    timestamp + grace period",
      "        if (block.timestamp < _timestamp) {",
      "            revert TimestampNotPassedError(block.timestamp, _timestamp);",
      "        }",
      "        if (block.timestamp > _timestamp + GRACE_PERIOD) {",
      "            revert TimestampExpiredError(block.timestamp, _timestamp + GRACE_PERIOD);",
      "        }",
      "        queued[txId] = false;",
      "        // prepare data",
      "        bytes memory data;",
      "        if (bytes(_func).length > 0) {",
      "            // data = func selector + _data",
      "            data = abi.encodePacked(bytes4(keccak256(bytes(_func))), _data);",
      "        } else {",
      "            // call fallback with data",
      "            data = _data;",
      "        }",
      "        // call target",
      "        (bool ok, bytes memory res) = _target.call{value: _value}(data);",
      "        if (!ok) {",
      "            revert TxFailedError();",
      "        }",
      "        emit Execute(txId, _target, _value, _func, _data, _timestamp);",
      "        return res;",
      "    }",
      "    function cancel(bytes32 _txId) external onlyOwner {",
      "        if (!queued[_txId]) {",
      "            revert NotQueuedError(_txId);",
      "        }",
      "        queued[_txId] = false;",
      "        emit Cancel(_txId);",
      "    }",
      "}",
      ""
    ],
    "prefix": "soltimelock"
  },
  "Minimal Proxy Contract Example": {
    "__typename": "Snippet",
    "label": "Minimal Proxy Contract Example",
    "description": "If you have a contract that will be deployed multiple times, use minimal proxy contract to deploy them cheaply",
    "body": [
      "// SPDX-License-Identifier: MIT",
      "pragma solidity ^0.8.13;",
      "// original code",
      "// https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol",
      "contract MinimalProxy {",
      "    function clone(address target) external returns (address result) {",
      "        // convert address to 20 bytes",
      "        bytes20 targetBytes = bytes20(target);",
      "        // actual code //",
      "        // 3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3",
      "        // creation code //",
      "        // copy runtime code into memory and return it",
      "        // 3d602d80600a3d3981f3",
      "        // runtime code //",
      "        // code to delegatecall to address",
      "        // 363d3d373d3d3d363d73 address 5af43d82803e903d91602b57fd5bf3",
      "        assembly {",
      "            /*",
      "            reads the 32 bytes of memory starting at pointer stored in 0x40",
      "            In solidity, the 0x40 slot in memory is special: it contains the \"free memory pointer\"",
      "            which points to the end of the currently allocated memory.",
      "            */",
      "            let clone := mload(0x40)",
      "            // store 32 bytes to memory starting at \"clone\"",
      "            mstore(",
      "                clone,",
      "                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000",
      "            )",
      "            /*",
      "              |              20 bytes                |",
      "            0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000",
      "                                                      ^",
      "                                                      pointer",
      "            */",
      "            // store 32 bytes to memory starting at \"clone\" + 20 bytes",
      "            // 0x14 = 20",
      "            mstore(add(clone, 0x14), targetBytes)",
      "            /*",
      "              |               20 bytes               |                 20 bytes              |",
      "            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe",
      "                                                                                              ^",
      "                                                                                              pointer",
      "            */",
      "            // store 32 bytes to memory starting at \"clone\" + 40 bytes",
      "            // 0x28 = 40",
      "            mstore(",
      "                add(clone, 0x28),",
      "                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000",
      "            )",
      "            /*",
      "              |               20 bytes               |                 20 bytes              |           15 bytes          |",
      "            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3",
      "            */",
      "            // create new contract",
      "            // send 0 Ether",
      "            // code starts at pointer stored in \"clone\"",
      "            // code size 0x37 (55 bytes)",
      "            result := create(0, clone, 0x37)",
      "        }",
      "    }",
      "}",
      ""
    ],
    "prefix": "solminproxy"
  }
}
